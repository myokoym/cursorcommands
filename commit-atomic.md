---
description: 原子的コミット実行（最小単位・個別ファイル指定）
allowed-tools: Bash, Read, Grep
argument-hint: [commit-message]
---

# Atomic Commit Executor

<background_information>
- **Mission**: 論理的に意味のある最小単位で、タスクに関連するファイルのみをコミット
- **Success Criteria**:
  - 一つのコミットには一つの変更目的のみ
  - タスクに無関係なファイルや変更は含めない
  - 機能追加とリファクタリングは別コミット
  - 既存プロジェクトのコミットフォーマットに準拠
</background_information>

<instructions>
## Core Task
作業区切りごとに原子的なコミットを実行する。

## Execution Steps

### Step 1: 変更内容の確認

**git statusとgit diffで変更を確認**:
```bash
git status
git diff --cached  # ステージ済みの変更
git diff           # 未ステージの変更
```

**分析ポイント**:
- どのファイルが変更されているか
- 変更の目的は何か（機能追加、バグ修正、リファクタリング等）
- 異なる目的の変更が混在していないか

### Step 2: コミット対象の選択

**原子性の原則**:
- **一つのコミットには一つの変更目的のみ**を含める
- 論理的に意味のある**最小の単位**で区切る

**スコープの原則**:
- **現在のタスクに直接関連するファイルのみ**をコミット対象とする
- タスクに無関係な変更（インデント修正、無関係なコメント等）は含めない

**分離の原則**:
- **機能の追加・変更**と**リファクタリング**は**必ず別コミット**
- 同じファイルへの変更でも、目的が異なれば分離する

### Step 3: 個別ファイル指定

**ファイルの個別指定**:
```bash
# 正しい例：個別ファイルを指定
git add src/components/Card.ts
git add src/scenes/DuelScene.ts

# 禁止例：一括追加
git add .        # 絶対禁止！
git add -A       # 絶対禁止！
```

**確認**:
```bash
git diff --cached
```

### Step 4: コミットメッセージの作成

**既存フォーマットの確認**:
```bash
git log --oneline -10
```

**基本方針**:
- 既存プロジェクトの`git log`のフォーマットと言語に合わせる
- 既存ログが一貫性に欠ける場合のみ、Conventional Commitsへの準拠を検討

**HEREDOCを使用したコミットメッセージ例**:
```bash
git commit -m "$(cat <<'EOF'
feat: デュエルシーンにターン表示を追加

- ターン数の状態管理を追加
- ターン表示UIコンポーネントを実装
EOF
)"
```

### Step 5: コミットの実行と確認

**コミット後の確認**:
```bash
git log -1
git status
```

## Critical Constraints

1. **最小単位のコミット（原子性）**
   - 論理的に意味のある最小の単位で作業を区切る
   - 一つのコミットには一つの変更目的のみ

2. **コミット対象の限定（スコープ）**
   - タスクに直接関連して変更されたファイルのみ
   - 無関係なファイルや変更は含めない

3. **論理的な分離の徹底**
   - 機能追加とリファクタリングは必ず別コミット
   - 同じファイルでも目的が異なれば分離

4. **コミット漏れの禁止**
   - 作業区切りごとに必ずコミット
   - コミットせずに次の作業に進まない

5. **個別ファイル指定の徹底**
   - `git add .` や `git add -A` は絶対禁止
   - 必ず個別ファイルを指定

</instructions>

## Usage Examples

**引数なし（対話的に確認してコミット）**:
```
/commit-atomic
```

AIが変更内容を確認し、適切なコミット対象とメッセージを提案します。

**引数あり（コミットメッセージを指定）**:
```
/commit-atomic feat: デュエルシーンにターン表示を追加
```

指定されたメッセージでコミットを実行します。

## Safety & Fallback

### 破壊的操作の禁止

**絶対禁止コマンド**:
- `git reset --hard`: 作業ディレクトリの変更も削除する破壊的操作。ユーザーの明示的な指示がない限り使用禁止。
- コミットの修正が必要な場合は、`git reset --soft`（ステージング状態を保持）または`git reset --mixed`（作業ディレクトリの変更を保持）を使用すること。

**推奨されない操作**:
- `git commit --amend`: 履歴を書き換える操作のため、`git reset --soft`を使用して複数コミットをまとめる方法を優先すること。

### 確認が必要な場合

**複数の変更目的が混在**:
- 機能追加とリファクタリングが同じファイルに含まれる場合
- **Action**: 変更を分離して複数のコミットに分ける

**タスクに無関係な変更が含まれる**:
- インデント修正、コメント追加など
- **Action**: 無関係な変更はコミットから除外、または別コミット

**コミット対象が不明確**:
- どのファイルをコミットすべきか判断できない
- **Action**: ユーザーに確認を求める

**ファイルの関連性が不明確**:
- 変更されたファイルが現在のタスクと関連しているか判断できない
- **Action**: ユーザーに確認を求める。推測してコミットに含めないこと

**サブモジュールの変更が含まれる**:
- サブモジュールディレクトリ（例: `.cursor/rules`）内のファイルを変更した場合
- **Action**: 
  1. まずサブモジュール側でコミット（サブモジュールディレクトリ内で`git add`と`git commit`）
  2. その後、メイン側でサブモジュール参照を更新（`git add .cursor/rules && git commit`）
  3. サブモジュール側の変更とメイン側の参照更新は必ず別のコミットとして分離
- **注意**: `git submodule update`は既存の参照に「戻す」操作なので、新しい参照を記録する場合は`git add`を使用すること

## Output Description

以下の情報を簡潔に報告:
1. **コミット対象**: どのファイルをコミットしたか
2. **変更の目的**: 何のための変更か
3. **コミットハッシュ**: 作成されたコミットのハッシュ

**Format**: 簡潔（100文字以内）

think
